from __future__ import print_function
import csv
from lxml import etree

class RouteStep:
    """One block step along a route."""
    def __init__(self, blockId, rating):
        self.blockId = blockId
        self.rating = rating

def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in range(0, len(l), n):
        yield l[i:i + n]

def append_node_with_text(parent, tagName, text):
    node = etree.SubElement(parent, tagName)
    node.text = text

def create_node(parent, tagName, name):
    folder = etree.SubElement(parent, tagName)
    append_node_with_text(folder, "name", name)
    return folder

def create_folder(parent, name):
    return create_node(parent, "Folder", name)

def create_rating_folder(parent, num):
    return create_folder(parent, "Rating" + str(num))

def append_line_style(parent, id, color, width):
    style = etree.SubElement(parent, "Style", id=id)
    lineStyle = etree.SubElement(style, "LineStyle")
    append_node_with_text(lineStyle, "color", color)
    append_node_with_text(lineStyle, "width", str(width))

def append_style_map(parent, id, normalId, highlightId):
    styleMap = etree.SubElement(parent, "StyleMap", id=id)
    append_style_map_pair(styleMap, "normal", normalId)
    append_style_map_pair(styleMap, "highlight", highlightId)

def append_style_map_pair(parent, key, styleId):
    pair = etree.SubElement(parent, "Pair")
    append_node_with_text(pair, "key", key)
    append_node_with_text(pair, "styleUrl", "#" + styleId)

def parseCsv(filePath, routesPerson, routesComp):
    with open(filePath, 'rb') as csvfile:
        reader = csv.reader(csvfile, delimiter=',')
        reader.next() # skip headers
        
        currentResident = None
        for row in reader:
            if row[1] != "":
                currentResident = row[1]
                routesPerson[currentResident] = []

            for i in chunks(row[5:], 2):
                if i[0] != "":
                    if (i[1] == ""):
                        print("Missing rating: " + i[0])
                    else:
                        blockId = i[0]
                        rating = int(i[1])
                        routesPerson[currentResident].append(RouteStep(blockId, rating))

                        # Populate compilations
                        if not routesComp.has_key(blockId):
                            routesComp[blockId] = []
                        routesComp[blockId].append(rating)

def fill_in_route_steps(routes, personFolder, person, coordinatesDict):

    ratingsDict = {
        1 : create_rating_folder(personFolder, 1),
        2 : create_rating_folder(personFolder, 2),
        3 : create_rating_folder(personFolder, 3)
    }

    for route_step in routes[person]:
        # Put the placemark in the right folder
        parentFolder = ratingsDict[route_step.rating]
        
        placemark = create_node(parentFolder, "Placemark", route_step.blockId)
        append_node_with_text(placemark, "visibility", "0")
        append_node_with_text(placemark, "styleUrl", "#" + str(route_step.rating) + "StyleMap")

        line_string = etree.SubElement(placemark, "LineString")
        append_node_with_text(line_string, "tessellate", "1")
        coordinates = etree.SubElement(line_string, "coordinates")
        
        if coordinatesDict.has_key(route_step.blockId):
            coordinates.text = coordinatesDict[route_step.blockId]
        else:
            print("Unknown streetblock2: \"" + route_step.blockId + "\"")

    # Remove ratings folders with no placemarks
    for rating in ratingsDict.keys():
        if len(ratingsDict[rating]) <= 1: personFolder.remove(ratingsDict[rating])

#  Read in street block mappings
print("Reading street blocks ... ", end="")

dockml = etree.parse('doc.kml')
root = dockml.getroot()
NSMAP = {'kml': 'http://www.opengis.net/kml/2.2', 'gx' : 'http://www.google.com/kml/ext/2.2'}

folder = dockml.xpath("//kml:Folder[./kml:name = 'STREETBLOCKS 11/8/16']", namespaces = NSMAP)[0]

coordinatesDict = {}
for placemark in folder.xpath('.//kml:Placemark', namespaces=NSMAP):
    #print(placemark[0].text, placemark[3][1].text.strip())
    coordinatesDict[placemark[0].text] = placemark[3][1].text.strip()

print(len(coordinatesDict))

#  Parse google sheets as CSV
walkingRoutesPerson = {} # Person -> array of route steps
walkingRoutesComp = {} # Block ID -> array of ratings
parseCsv('walking.csv', walkingRoutesPerson, walkingRoutesComp)

bikingRoutesPerson = {} # Person -> array of route steps
bikingRoutesComp = {} # Block ID -> array of ratings
parseCsv('biking.csv', bikingRoutesPerson, bikingRoutesComp)

# Create main Kml structure
kml = etree.Element('kml', nsmap=NSMAP)
document = create_node(kml, "Document", "Generated by Python")
residentsFolder = create_folder(document, "Residents")
compilationsFolder = create_folder(document, "Compilations")
append_line_style(document, "green", "ff00ff00", 2)
append_line_style(document, "yellow", "ff00ffff", 2)
append_line_style(document, "red", "ff0000ff", 2)
append_line_style(document, "highlight", "ffaaaaaa", 2)
append_style_map(document, "1StyleMap", "red", "highlight")
append_style_map(document, "2StyleMap", "yellow", "highlight")
append_style_map(document, "3StyleMap", "green", "highlight")

# Populate resident nodes
for person in walkingRoutesPerson.keys():
    personFolder = create_folder(residentsFolder, person)

    walkingFolderPerson = create_folder(personFolder, "Walking")
    bikingFolderPerson = create_folder(personFolder, "Biking")

    fill_in_route_steps(walkingRoutesPerson, walkingFolderPerson, person, coordinatesDict)
    fill_in_route_steps(bikingRoutesPerson, bikingFolderPerson, person, coordinatesDict)

def populate_compulations(routesComp, rootFolder):
    for blockId in routesComp.keys():
        rating = max(routesComp[blockId])

        placemark = create_node(rootFolder, "Placemark", blockId)
        append_node_with_text(placemark, "visibility", "0")
        append_node_with_text(placemark, "styleUrl", "#" + str(rating) + "StyleMap")

        line_string = etree.SubElement(placemark, "LineString")
        append_node_with_text(line_string, "tessellate", "1")
        coordinates = etree.SubElement(line_string, "coordinates")
        
        if coordinatesDict.has_key(blockId):
            coordinates.text = coordinatesDict[blockId]
        else:
            print("Unknown streetblock: \"" + blockId + "\"")

# Populate compilations
walkingFolderComp = create_folder(compilationsFolder, "Walking")
bikingFolderComp = create_folder(compilationsFolder, "Biking")

populate_compulations(walkingRoutesComp, walkingFolderComp)
populate_compulations(bikingRoutesComp, bikingFolderComp)

# Write out final Kml file
with open('python_generated.kml', 'w') as generatedKml:
    generatedKml.write('<?xml version="1.0" encoding="UTF-8"?>' '\n')
    generatedKml.write(etree.tounicode(kml, pretty_print=True))
    generatedKml.close()